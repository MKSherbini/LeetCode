#pragma once

// assume answer and try to prove it with searching
// int vis = (taken & (1 << i));  taken | (1 << i)

// MinimumWindowSubstring, use frequence as equilibrium to check characters matching with sliding window
// SetMismatch, use array index and values +ve/-ve to mark visited

//int dx[] = { 1,-1,0,0 };
//int dy[] = { 0,0,1,-1 };
//
//for (int i = 0; i < 4; i++)

//bool valid(int x, int n) {
//	return x >= 0 && x < n;
//}

// 26 1 case, 

//	std::lower_bound - returns iterator to first element in the given range which is EQUAL_TO or Greater than val.
//	std::upper_bound - returns iterator to first element in the given range which is Greater than val.

// intersecting intervals min(a[1], b[1]) >= max(a[0], b[0])